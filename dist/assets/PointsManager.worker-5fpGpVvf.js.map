{"version":3,"file":"PointsManager.worker-5fpGpVvf.js","sources":["../src/splats/radix/wasm_sorter.js","../src/splats/PointsManager.js","../src/splats/PointsManager.worker.js"],"sourcesContent":["let wasm;\r\n\r\nlet cachedUint32ArrayMemory0 = null;\r\n\r\nfunction getUint32ArrayMemory0() {\r\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\r\n        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\r\n    }\r\n    return cachedUint32ArrayMemory0;\r\n}\r\n\r\nlet WASM_VECTOR_LEN = 0;\r\n\r\nfunction passArray32ToWasm0(arg, malloc) {\r\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\r\n    getUint32ArrayMemory0().set(arg, ptr / 4);\r\n    WASM_VECTOR_LEN = arg.length;\r\n    return ptr;\r\n}\r\n\r\nfunction getArrayU32FromWasm0(ptr, len) {\r\n    ptr = ptr >>> 0;\r\n    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\r\n}\r\n/**\r\n * Radix Sort implementation for sorting indices based on distances.\r\n * Both `indices` and `distances` should have the same length.\r\n * Returns a new vector of sorted indices in descending order based on distances.\r\n * @param {Uint32Array} indices\r\n * @param {Uint32Array} distances\r\n * @returns {Uint32Array}\r\n */\r\nexport function radix_sort_indices(indices, distances) {\r\n    const ptr0 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\r\n    const len0 = WASM_VECTOR_LEN;\r\n    const ptr1 = passArray32ToWasm0(distances, wasm.__wbindgen_malloc);\r\n    const len1 = WASM_VECTOR_LEN;\r\n    const ret = wasm.radix_sort_indices(ptr0, len0, ptr1, len1);\r\n    var v3 = getArrayU32FromWasm0(ret[0], ret[1]).slice();\r\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\r\n    return v3;\r\n}\r\n\r\nasync function __wbg_load(module, imports) {\r\n    if (typeof Response === 'function' && module instanceof Response) {\r\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\r\n            try {\r\n                return await WebAssembly.instantiateStreaming(module, imports);\r\n\r\n            } catch (e) {\r\n                if (module.headers.get('Content-Type') != 'application/wasm') {\r\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\r\n\r\n                } else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n\r\n        const bytes = await module.arrayBuffer();\r\n        return await WebAssembly.instantiate(bytes, imports);\r\n\r\n    } else {\r\n        const instance = await WebAssembly.instantiate(module, imports);\r\n\r\n        if (instance instanceof WebAssembly.Instance) {\r\n            return { instance, module };\r\n\r\n        } else {\r\n            return instance;\r\n        }\r\n    }\r\n}\r\n\r\nfunction __wbg_get_imports() {\r\n    const imports = {};\r\n    imports.wbg = {};\r\n    imports.wbg.__wbindgen_init_externref_table = function() {\r\n        const table = wasm.__wbindgen_export_0;\r\n        const offset = table.grow(4);\r\n        table.set(0, undefined);\r\n        table.set(offset + 0, undefined);\r\n        table.set(offset + 1, null);\r\n        table.set(offset + 2, true);\r\n        table.set(offset + 3, false);\r\n        ;\r\n    };\r\n\r\n    return imports;\r\n}\r\n\r\nfunction __wbg_init_memory(imports, memory) {\r\n\r\n}\r\n\r\nfunction __wbg_finalize_init(instance, module) {\r\n    wasm = instance.exports;\r\n    __wbg_init.__wbindgen_wasm_module = module;\r\n    cachedUint32ArrayMemory0 = null;\r\n\r\n\r\n    wasm.__wbindgen_start();\r\n    return wasm;\r\n}\r\n\r\nfunction initSync(module) {\r\n    if (wasm !== undefined) return wasm;\r\n\r\n\r\n    if (typeof module !== 'undefined') {\r\n        if (Object.getPrototypeOf(module) === Object.prototype) {\r\n            ({module} = module)\r\n        } else {\r\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\r\n        }\r\n    }\r\n\r\n    const imports = __wbg_get_imports();\r\n\r\n    __wbg_init_memory(imports);\r\n\r\n    if (!(module instanceof WebAssembly.Module)) {\r\n        module = new WebAssembly.Module(module);\r\n    }\r\n\r\n    const instance = new WebAssembly.Instance(module, imports);\r\n\r\n    return __wbg_finalize_init(instance, module);\r\n}\r\n\r\nasync function __wbg_init(module_or_path) {\r\n    if (wasm !== undefined) return wasm;\r\n\r\n\r\n    if (typeof module_or_path !== 'undefined') {\r\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\r\n            ({module_or_path} = module_or_path)\r\n        } else {\r\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\r\n        }\r\n    }\r\n\r\n    if (typeof module_or_path === 'undefined') {\r\n        module_or_path = new URL('wasm_sorter_bg.wasm', import.meta.url);\r\n    }\r\n    const imports = __wbg_get_imports();\r\n\r\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\r\n        module_or_path = fetch(module_or_path);\r\n    }\r\n\r\n    __wbg_init_memory(imports);\r\n\r\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\r\n\r\n    return __wbg_finalize_init(instance, module);\r\n}\r\n\r\nexport { initSync };\r\nexport default __wbg_init;\r\n","import init, { radix_sort_indices } from './radix/wasm_sorter.js';\r\n\r\nconst buffer = new ArrayBuffer(4);\r\nconst floatView = new Float32Array(buffer);\r\nconst uintView = new Uint32Array(buffer);\r\n\r\nclass PointsManager {\r\n    constructor(sortCallback) {\r\n        this.points = new Float32Array(4096  * 3);\r\n        this.distances = new Uint32Array(4096);\r\n        this.pointSets = new Map(); // Map<number, object>\r\n        this.numUsed = 0;\r\n        this.sortOngoing = false;\r\n        this.sortCallback = sortCallback;\r\n        this.sortPromise = Promise.resolve();\r\n    }\r\n\r\n\r\n\r\n    hidePoints(insertionIndex) {\r\n        //console.log(\"hide\");\r\n        const pointSet = this.pointSets.get(insertionIndex);\r\n        if (pointSet.used) {\r\n            pointSet.used = false;\r\n        }\r\n    }\r\n    removePoints(insertionIndex) {\r\n        /* console.log(\"remove\"); */\r\n        const pointSet = this.pointSets.get(insertionIndex);\r\n        if (pointSet.used) {\r\n            pointSet.used = false;\r\n        }\r\n\r\n        this.pointSets.delete(insertionIndex);\r\n\r\n        // Determine newLength based on remaining points\r\n        let newLength = 0;\r\n        for (const [key, aPointSet] of this.pointSets.entries()) {\r\n            if (key + aPointSet.length > newLength) {\r\n                newLength = key + aPointSet.length;\r\n            }\r\n        }\r\n\r\n    }\r\n    showPoints(insertionIndex) {\r\n        /* console.log(\"show\"); */\r\n        const pointSet = this.pointSets.get(insertionIndex);\r\n        if (!pointSet.used) {\r\n            pointSet.used = true;\r\n        }\r\n\r\n    }\r\n\r\n    resizeArrays(newLength) {\r\n\r\n        if (isNaN(newLength)) {\r\n            console.log(\"hit max splats\")\r\n        }\r\n        //console.log(newLength)\r\n        if (newLength > this.points.length) {\r\n            newLength = Math.max(this.points.length * 2, newLength);\r\n            // Resize points array\r\n            const newPoints = new Float32Array(newLength);\r\n            newPoints.set(this.points, 0);\r\n            this.points = newPoints;\r\n\r\n            // Resize distances array\r\n            const newNumPoints = Math.floor(newLength / 3);\r\n            const newDistances = new Uint32Array(newNumPoints);\r\n            newDistances.set(this.distances, 0);\r\n            this.distances = newDistances;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    addBatchesOffsetStrideCount(positions, insertionIndexes, offset, stride, batchSize) {\r\n\r\n        const newLength = Math.max(this.points.length, insertionIndexes[insertionIndexes.length - 1] + batchSize * 3);\r\n\r\n        this.resizeArrays(newLength);\r\n        for (let batchIndex = 0; batchIndex < insertionIndexes.length; batchIndex++) {\r\n\r\n            const insertionIndex = insertionIndexes[batchIndex];\r\n            const start = Math.floor(insertionIndex / 3);\r\n            const batchPositionStartIndex = batchIndex * batchSize * stride;\r\n            const batchNumPoints = Math.min((positions.length - batchPositionStartIndex) / stride, batchSize);\r\n\r\n\r\n            for (let i = 0; i < batchNumPoints; i++) {\r\n\r\n                this.points[insertionIndex + i * 3] = positions[i * stride + offset + batchPositionStartIndex]\r\n                this.points[insertionIndex + i * 3 + 1] = positions[i * stride + offset + batchPositionStartIndex + 1]\r\n                this.points[insertionIndex + i * 3 + 2] = positions[i * stride + offset + batchPositionStartIndex + 2]\r\n\r\n            }\r\n            this.pointSets.set(insertionIndex, { length: batchNumPoints * 3, used: false });\r\n\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    computeDistances(x, y, z) {\r\n\r\n        this.distances.fill(0);\r\n        const keys = Array.from(this.pointSets.keys());\r\n        const numKeys = keys.length;\r\n        this.numUsed = 0;\r\n        for (let i = 0; i < numKeys; i++) {\r\n            const key = keys[i];\r\n            const pointSet = this.pointSets.get(key);\r\n            if (!pointSet.used) continue;\r\n            const length = Math.floor(pointSet.length / 3);\r\n            this.numUsed += length\r\n        }\r\n        //console.log(\"num used : \"+this.numUsed);\r\n        this.indexes = new Uint32Array(this.numUsed);\r\n        this.distances = new Uint32Array(this.numUsed);\r\n        let c = 0;\r\n        for (let i = 0; i < numKeys; i++) {\r\n            const key = keys[i];\r\n            const keyBase = Math.floor(key / 3);\r\n            const pointSet = this.pointSets.get(key);\r\n            if (!pointSet.used) continue;\r\n            const length = Math.floor(pointSet.length / 3);\r\n            //this.numUsed += length\r\n            for (let j = 0; j < length; j++) {\r\n                const idx = key + (j * 3);\r\n                const dx = x - this.points[idx];\r\n                const dy = y - this.points[idx + 1];\r\n                const dz = z - this.points[idx + 2];\r\n                const d = dx*dx + dy*dy + dz*dz;\r\n                floatView[0] = d;\r\n                this.distances[c] = uintView[0];\r\n                this.indexes[c++] = keyBase + j;\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    sort(xyz, id) {\r\n        // Always store the latest sort request\r\n\r\n        this.pendingSort = xyz;\r\n        this.pendingID = id;\r\n        //console.log(`Received sort request with ID: ${id}`);\r\n\r\n        // If no sort is currently ongoing, start processing\r\n        if (!this.sortOngoing) {\r\n            this.sortOngoing = true;\r\n            this.processSortQueue();\r\n        }\r\n    }\r\n\r\n    // Asynchronous loop to process sort requests sequentially\r\n    async processSortQueue() {\r\n        if(!this.initialized){\r\n            await init();\r\n            this.initialized = true;\r\n        }\r\n        while (this.pendingSort) {\r\n            const currentSort = this.pendingSort;\r\n            const currentID = this.pendingID;\r\n\r\n            // Clear the pending sort to capture any new requests during processing\r\n            this.pendingSort = null;\r\n            this.pendingID = null;\r\n\r\n            //console.log(`Starting sort with ID: ${currentID}`);\r\n\r\n            const start = performance.now();\r\n\r\n            // Perform the synchronous sort operations\r\n            this.computeDistances(currentSort[0], currentSort[1], currentSort[2]);\r\n            //console.log((performance.now() - start)+' ms');\r\n        \r\n            //console.log(this.indexes.length)\r\n            \r\n            this.indexes = radix_sort_indices(this.indexes, this.distances);\r\n            /* radixSort(this.indexes, {\r\n                get: (el) => this.distances[el],\r\n                reversed: true\r\n            }); */\r\n            \r\n            const duration = performance.now() - start;\r\n            //console.log(`Sort with ID: ${currentID} completed in ${duration.toFixed(2)}ms`);\r\n\r\n            // Callback after sorting is done\r\n            this.sortCallback(this.indexes, this.numUsed, currentID);\r\n\r\n            // Yield control to the event loop to handle new incoming sort requests\r\n            await new Promise(resolve => setTimeout(resolve, 0));\r\n        }\r\n\r\n        // No more pending sorts\r\n        this.sortOngoing = false;\r\n        //console.log(\"No more pending sorts. SortWorker is idle.\");\r\n    }\r\n} export { PointsManager }","import { PointsManager } from \"./PointsManager\";\r\n\r\nconst sortCallback = ((array, numUsed, id)=>{\r\n    const copy = new Uint32Array(array)\r\n    postMessage({\r\n        order: copy.buffer,\r\n        count: numUsed,\r\n        id: id\r\n    }, [copy.buffer]);\r\n})\r\nlet pointsManager;\r\nself.onmessage = function (e) {\r\n\r\n    try {\r\n\r\n        switch (e.data.method) {\r\n            \r\n            case \"addBatches\":\r\n                if (!pointsManager) {\r\n                    pointsManager = new PointsManager(sortCallback);\r\n                }\r\n                pointsManager.addBatchesOffsetStrideCount(new Float32Array(e.data.positions), e.data.insertionIndexes, e.data.offset, e.data.stride, e.data.batchSize);\r\n                break\r\n            case \"hide\":\r\n\r\n                if (!!pointsManager) {\r\n                    pointsManager.hidePoints(e.data.insertionIndex);\r\n                }\r\n\r\n                break\r\n            case \"hideBatches\":\r\n\r\n                if (!!pointsManager) {\r\n                    e.data.insertionIndexes.forEach(insertionIndex => {\r\n                        pointsManager.hidePoints(insertionIndex);\r\n                    });\r\n                    pointsManager.sort(e.data.xyz, e.data.id)\r\n                }\r\n\r\n                break\r\n            case \"show\":\r\n\r\n                if (!!pointsManager) {\r\n                    pointsManager.showPoints(e.data.insertionIndex);\r\n                    pointsManager.sort(e.data.xyz, e.data.id)\r\n                }\r\n\r\n                break;\r\n            case \"showBatches\":\r\n\r\n                if (!!pointsManager) {\r\n                    e.data.insertionIndexes.forEach(insertionIndex => {\r\n                        pointsManager.showPoints(insertionIndex);\r\n                    });\r\n                    pointsManager.sort(e.data.xyz, e.data.id)\r\n                }\r\n\r\n                break\r\n            case \"remove\":\r\n                if (!!pointsManager) {\r\n                    pointsManager.removePoints(e.data.insertionIndex);\r\n                    pointsManager.sort(e.data.xyz, e.data.id)\r\n                }\r\n\r\n                break\r\n            case \"removeBatches\":\r\n\r\n                if (!!pointsManager) {\r\n                    e.data.insertionIndexes.forEach(insertionIndex => {\r\n                        pointsManager.removePoints(insertionIndex);\r\n                    });\r\n                    pointsManager.sort(e.data.xyz, e.data.id)\r\n                }\r\n\r\n                break\r\n            case \"sort\":\r\n                if (!!pointsManager) {\r\n                    pointsManager.sort(e.data.xyz, e.data.id)\r\n                }\r\n                break\r\n            default:\r\n                throw new Error(`No method with name ${e.data.method}`)\r\n        }\r\n    } catch (error) {\r\n        postMessage({ error: error.message })\r\n    }\r\n}"],"names":["wasm","cachedUint32ArrayMemory0","getUint32ArrayMemory0","WASM_VECTOR_LEN","passArray32ToWasm0","arg","malloc","ptr","getArrayU32FromWasm0","len","radix_sort_indices","indices","distances","ptr0","len0","ptr1","len1","ret","v3","__wbg_load","module","imports","e","bytes","instance","__wbg_get_imports","table","offset","__wbg_finalize_init","__wbg_init","module_or_path","buffer","floatView","uintView","PointsManager","sortCallback","insertionIndex","pointSet","newLength","key","aPointSet","newPoints","newNumPoints","newDistances","positions","insertionIndexes","stride","batchSize","batchIndex","batchPositionStartIndex","batchNumPoints","i","x","y","z","keys","numKeys","length","c","keyBase","j","idx","dx","dy","dz","d","xyz","id","init","currentSort","currentID","start","resolve","array","numUsed","copy","pointsManager","error"],"mappings":"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"}